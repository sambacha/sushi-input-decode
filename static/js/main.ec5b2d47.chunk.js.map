{"version":3,"sources":["mm.png","utils.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["analyseTxData","raw","knownInterfaces","args","funcFragment","found","i","decodeFunctionData","ethers","utils","hexDataSlice","getFunction","error","parsedArgs","map","argCall","type","inputs","name","colors","Arg","arg","layer","functionIndent","className","BigNumber","isBigNumber","toString","JSON","stringify","style","marginLeft","marginTop","padding","borderRadius","backgroundColor","length","App","useState","data","setData","decodedData","setDecodedData","Interface","GnosisSafe","abi","ERC20","useEffect","src","metamask","alt","height","value","onChange","e","target","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"y96vBAAe,MAA0B,+B,wBCY5BA,EAAgB,SAAhBA,EACXC,EACAC,GAEA,IAAIC,EACAC,EAFW,EAGXC,GAAQ,EAHG,cAIDH,GAJC,IAIf,2BAA+B,CAAC,IAAvBI,EAAsB,QAE7B,IAEEH,EAAOG,EAAEC,mBAAmBC,IAAOC,MAAMC,aAAaT,EAAK,EAAG,GAAIA,GAElEG,EAAeE,EAAEK,YAAYH,IAAOC,MAAMC,aAAaT,EAAK,EAAG,IAC/DI,GAAQ,EACR,MACA,MAAOO,GAEP,WAfW,8BAkBf,IAAKP,EAEH,MAAO,CAAEJ,OAGX,IAAMY,EAAaV,EAAMW,KAAI,SAACC,EAAST,GACrC,OAAO,2BACFN,EAAce,EAASb,IAD5B,IAEEc,KAAMZ,EAAca,OAAOX,GAAGU,KAC9BE,KAAMd,EAAca,OAAOX,GAAGY,UAGlC,MAAO,CAAEd,eAAcS,aAAYZ,Q,uBCpC/BkB,EAAS,CAAC,UAAW,UAAW,UAAW,WAEjD,SAASC,EAAT,GAAuE,IAAxDC,EAAuD,EAAvDA,IAAuD,IAAlDC,aAAkD,MAA1C,EAA0C,EAC9DC,EAAyB,EAARD,EAAY,KACnC,OACE,sBAAKE,UAAU,MAAf,UACGF,EAAQ,GACP,gCACE,iCACGD,EAAIL,KADP,IACcK,EAAIH,KADlB,IACyB,OAExBV,IAAOiB,UAAUC,YAAYL,EAAIpB,KAChC,iCAAOoB,EAAIpB,IAAI0B,WAAf,OAEA,iCAAOC,KAAKC,UAAUR,EAAIpB,KAA1B,UAILoB,EAAIjB,cACH,sBACE0B,MAAO,CACLC,WAAYR,EACZS,UAAW,MACXC,QAAS,QACTC,aAAc,MACdC,gBAAiBhB,EAAOG,EAAQH,EAAOiB,SAN3C,UASGd,EAAQ,GAAK,iEACd,gCACE,4BAAID,EAAIjB,aAAac,KAAO,MAC3BG,EAAIR,YACHQ,EAAIR,WAAWC,KAAI,SAACO,EAAKf,GAAN,OACjB,6BACE,6BACE,cAACc,EAAD,CAAKC,IAAKA,EAAKC,MAAOA,EAAQ,OAFzBhB,SAOf,4BAAI,YAqCC+B,MA9Bf,WAAgB,IAAD,EACWC,mBACtB,80CAFW,mBACNC,EADM,KACAC,EADA,OAIyBF,mBAAqB,CACzDrC,IAAK,eALM,mBAINwC,EAJM,KAIOC,EAJP,OAQeJ,mBAAS,CACnC,IAAI9B,IAAOC,MAAMkC,UAAUC,EAAWC,KACtC,IAAIrC,IAAOC,MAAMkC,UAAUG,EAAMD,OAF5B3C,EARM,oBAiBb,OAJA6C,qBAAU,WACRL,EAAe1C,EAAcuC,EAAMrC,MAClC,CAACqC,EAAMrC,IAGR,sBAAKsB,UAAU,MAAf,UACE,qBAAKA,UAAU,QAAf,SACE,yDAEF,qBAAMwB,IAAKC,EAAUC,IAAI,mBAAmBC,OAAO,QACnD,6CACA,0BAAUC,MAAOb,EAAMc,SAAU,SAACC,GAAD,OAAOd,EAAQc,EAAEC,OAAOH,UACzD,cAAChC,EAAD,CAAKC,IAAKoB,QCnEDe,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.ec5b2d47.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/mm.9c0e035f.png\";","import { ethers } from \"ethers\";\n\nexport interface ArgDecoded {\n  raw: string;\n  funcFragment?: ethers.utils.FunctionFragment;\n  parsedArgs?: ArgDecoded[];\n  type?: string;\n  name?: string;\n}\n\n// Analyse transaction arguments, and recursively check if an argument is\n// an encoded function call\nexport const analyseTxData = (\n  raw: string,\n  knownInterfaces: ethers.utils.Interface[]\n): ArgDecoded => {\n  var args: ethers.utils.Result | undefined;\n  var funcFragment: ethers.utils.FunctionFragment | undefined;\n  var found = false;\n  for (let i of knownInterfaces) {\n    // try to decode an encoded function call\n    try {\n      // decode arguments into array\n      args = i.decodeFunctionData(ethers.utils.hexDataSlice(raw, 0, 4), raw);\n      // get ethersjs function fragment (name and inputs types)\n      funcFragment = i.getFunction(ethers.utils.hexDataSlice(raw, 0, 4));\n      found = true;\n      break;\n    } catch (error) {\n      // try another interface\n      continue;\n    }\n  }\n  if (!found) {\n    // not an encoded function call, return the argument\n    return { raw };\n  }\n  // inject the type of each argument object into parsedArgs\n  const parsedArgs = args!.map((argCall, i) => {\n    return {\n      ...analyseTxData(argCall, knownInterfaces),\n      type: funcFragment!.inputs[i].type,\n      name: funcFragment!.inputs[i].name,\n    };\n  });\n  return { funcFragment, parsedArgs, raw };\n};\n","import React, { useState, useEffect } from \"react\";\nimport { ethers } from \"ethers\";\n\nimport metamask from \"./mm.png\"\nimport \"./App.css\";\nimport { analyseTxData, ArgDecoded } from \"./utils\";\nimport GnosisSafe from \"./abis/gnosis.json\";\nimport ERC20 from \"./abis/ERC20.json\";\n\nconst colors = [\"#d4ebc3\", \"#c3c3eb\", \"#e0c3eb\", \"#ebc3c3\"];\n\nfunction Arg({ arg, layer = 0 }: { arg: ArgDecoded; layer?: number }) {\n  const functionIndent = layer * 3 + \"em\";\n  return (\n    <div className=\"Arg\">\n      {layer > 0 && (\n        <div>\n          <span>\n            {arg.type} {arg.name}:{\" \"}\n          </span>\n          {ethers.BigNumber.isBigNumber(arg.raw) ? (\n            <span>{arg.raw.toString()},</span>\n          ) : (\n            <span>{JSON.stringify(arg.raw)},</span>\n          )}\n        </div>\n      )}\n      {arg.funcFragment && (\n        <div\n          style={{\n            marginLeft: functionIndent,\n            marginTop: \"1em\",\n            padding: \"0.8em\",\n            borderRadius: \"1em\",\n            backgroundColor: colors[layer % colors.length],\n          }}\n        >\n          {layer > 0 && <b>Found an encoded function call !</b>}\n          <div>\n            <b>{arg.funcFragment.name + \"(\"}</b>\n            {arg.parsedArgs &&\n              arg.parsedArgs.map((arg, i) => (\n                <ul key={i}>\n                  <li>\n                    <Arg arg={arg} layer={layer + 1} />\n                  </li>\n                </ul>\n              ))}\n          </div>\n          <b>{\")\"}</b>\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction App() {\n  const [data, setData] = useState<string>(\n    \"0x6a7612020000000000000000000000004ba1a50aecba077acdf4625bf9adb3fe964eea170000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008b67000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000064f8dc5dd90000000000000000000000000532fb8f096decb82ace8b3f67f5c11aebe02c140000000000000000000000004421e2bde12fabbd4306642e8ec73a5d2d87d99a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000821706fbbe2f5021d28a9323e4e804ececb8b4c96f056746f8d50fb1610817ee100ae268c83a04238bc87ad19c1880f2a5f1055e3ee2fe86d5b2a5cbd2c3bfb8ae1b000000000000000000000000e6220257d157ec7b481290fd10d2037cf0e83ea5000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000\"\n  );\n  const [decodedData, setDecodedData] = useState<ArgDecoded>({\n    raw: \"loading...\",\n  });\n\n  const [knownInterfaces, ] = useState([\n    new ethers.utils.Interface(GnosisSafe.abi),\n    new ethers.utils.Interface(ERC20.abi),\n  ]);\n\n  useEffect(() => {\n    setDecodedData(analyseTxData(data, knownInterfaces));\n  }, [data, knownInterfaces]);\n\n  return (\n    <div className=\"App\">\n      <div className=\"Title\">\n        <h1>tx input data checker</h1>\n      </div>\n      <img  src={metamask} alt=\"Metamask example\" height=\"400\"></img>\n      <h2>Input data:</h2>\n      <textarea value={data} onChange={(e) => setData(e.target.value)} />\n      <Arg arg={decodedData} />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}